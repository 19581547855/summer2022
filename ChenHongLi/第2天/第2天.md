1、信号量是一种轻型的用于解决线程间同步问题的内核对象，线程可以获取或释放它， 从而达到同步或互斥的目的。信号量就像一把钥匙，把一段临界区给锁住，只允许 有钥匙的线程进行访问：线程拿到了钥匙，才允许它进入临界区；而离开后把钥匙 传递给排队在后面的等待线程，让后续线程依次进入临界区。
2、互斥量又叫相互排斥的信号量，是一种特殊的二值性信号量。它和信号量不同的是， 它支持互斥量所有权、递归访问以及防止优先级翻转的特性。

互斥量的使用比较单一，因为它是信号量的一种，并且它是以锁的形式存在。 在初始化的时候，互斥量永远都处于开锁的状态，而被线程持有的时候则立刻转为 闭锁的状态。互斥量更适合于：

-   线程多次持有互斥量的情况下。这样可以避免同一线程多次递归持有而造成死锁的问题；
-   可能会由于多线程同步而造成优先级翻转的情况；
3、事件主要用于线程间的同步，与信号量不同，它的特点是可以实现一对多，多对多的同步。 事件另外一个特性是，接收线程可等待多种事件，即多个事件对应一个线程或多个线程。 同时按照线程等待的参数，可选择是 “逻辑或” 触发还是 “逻辑与” 触发。

-   事件只与线程相关，事件间相互独立：每个线程拥有 32 个事件标志，采用一个 32 bit 无符号整型数进行记录，每一个 bit 代表一个事件。若干个事件构成一个事件集；
-   事件仅用于同步，不提供数据传输功能；
-   事件无排队性，即多次向线程发送同一事件 (如果线程还未来得及读走)，其效果等同于只 发送一次。

4、邮箱是一种简单的线程间消息传递方式，在 RT-Thread 操作系统的实现中能够一次传递 4 字节邮件， 并且邮箱具备一定的存储功能，能够缓存一定数量的邮件数 (邮件数由创建、初始化邮箱时指定的 容量决定)。邮箱中一封邮件的最大长度是 4 字节，所以邮箱能够用于不超过 4 字节的消息传递， 当传送的消息长度大于这个数目时就不能再采用邮箱的方式。当消邮箱不再被使用时，应该删除它以释放系统资源，一旦操作完成，邮箱将被永久性的删除。
5、消息队列是另一种常用的线程间通讯方式，它能够接收来自线程或中断服务例程中不固定长度的消息， 并把消息缓存在自己的内存空间中。其他线程也能够从消息队列中读取相应的消息，而当消息队列是 空的时候，可以挂起读取线程。当有新的消息到达时，挂起的线程将被唤醒以接收并处理消息。消息 队列是一种异步的通信方式。
当消息队列不再被使用时，应该删除它以释放系统资源，一旦操作完成，消息队列将被永久性的删除。

6、静态内存池   内存池（Memory Pool）是一种用于分配大量大小相同的小内存对象的技术。它可以极大加快内存分配/释放的速度。内存池在创建时先向系统申请一大块内存，然后分成大小相等的多个小内存块，小内存块直接通过链表连接起来（此链表也称为空闲内存链表）。每次分配的时候，从空闲内存链表中取出表头上第一个内存块，提供给申请者。物理内存中允许存在多个大小不同的内存池，每一个内存池又由多个大小相同的空闲内存块组成。当一个内存池对象被创建时，内存池对象就被分配给了一个内存池控制块，内存控制块的参数包括内存池名，内存缓冲区，内存块大小，块数以及一个等待线程列表。 内核负责给内存池分配内存池对象控制块，它同时也接收用户线程的分配内存块申请，当获得申请信息后，内核就可以从内存池中为线程分配内存块。内存池一旦初始化完成，内部的内存块大小将不能再做调整。
 动态内存分配RT-Thread 系统为了满足不同的需求，提供了两套不同的动态内存管理算法，分别是小堆内存管理算法和 SLAB 内存管理算法。小内存管理算法是一个简单的内存分配算法。初始时，它是一块大的内存，其大小为（MEM_SIZE），当需要分配内存块时，将从这个大的内存块上分割出相匹配的内存块，然后把分割出来的空闲内存块还回给堆管理系统中。每个内存块都包含一个管理用的数据头，通过这个头把使用块与空闲块用双向链表的方式链接起来（内存块链表）