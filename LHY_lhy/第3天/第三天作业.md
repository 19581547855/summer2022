## 信号量 

#### 获取信号量

##### rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)

在确定sem的值>0时,直接进行自减.

​	小于0并且超时时间为0,直接返回-ET_ETIMEOUT

​	有超时时间就获取当前线程,然后挂起并且打开线程内定时器,在超时函数中从挂起	列表中移出,并挂载到ready列表中,启动调度器.

##### rt_err_t rt_sem_trytake(rt_sem_t sem)

与上同,唯一不同之处就是不进行等待,如果没有take到,直接返回,不挂起线程.

#### 释放信号量

##### rt_err_t rt_sem_release(rt_sem_t sem)

​	在进行完断言和设置对象钩子之后,会检查当前信号量的挂起队列中是否为空

- 如果不是空,就resume当前挂起的第一个线程,然后设置调度器标志为需要调度.

- 如果是空,判断信号量的值是否小于最大值,小于就自增,大于就返回efull

#### 删除信号量

delete和detach都会把sem中挂起列表的所有线程移除,但是并不调度.

# 互斥量

#### 获取互斥量

##### rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)

首先获取当前线程,然后判断当前互斥量的所有者是否是当前线程

- 如果是,再判断当前互斥量的hold层是否超过最大值,如果超过就i返回efull,如果没有超过就自增.
- 如果不是就判断互斥量的value是否大于零,如果是,就自减,并且hold层数加一;如果不是就再看超时时间,如果超时时间为0,就直接返回-etimeout,如果有超时时间,就把判断当前线程优先级是否是小于mutex的持有者的优先级,如果小与,就改变当前线程的优先级为mutex的持有者的优先级.然后挂起当前线程.如果超时时间不为0,就启动定时器,在定时器回调中释放线程并返回etimeout

##### rt_err_t rt_mutex_trytake(rt_mutex_t mutex)

同上,唯一不同就是超时时间为0,如果没有互斥量,就直接返回错误

#### 释放互斥量

#### rt_err_t rt_mutex_release(rt_mutex_t mutex)

首先获取当前线程,然后判断当前的线程是否与互斥量的持有线程一致,如果不一致,直接返回错误,因为互斥量只能被其持有的线程释放.

判断之后就让互斥量的hold层减一,然后判断hold层是否为0

如果为0,就改变当前线程的优先级为原来的优先级,然后判断互斥量的挂起列表是否为空,如果不为空//,就获取当前挂起线程的第一个,更改互斥量的所有者为此线程,然后hold层自增.最后从挂起线程中恢复此线程.然后启动调度器//如果为空,就判断互斥量的value是否小于其最大值,如果小于就自增,如果不是,就返回-efull;然后设定所有者为null,mutex的原始优先级为0xff

#### 删除互斥量

delete和detach都会释放在互斥量中挂起的所有线程,但是并不进行调度

# 事件

### 接收事件

##### rt_err_t rt_event_recv();

在状态判断之后,会选择一下,如果判断事件没有OK,就判断超时时间,如果超时时间也为0,就直接返回etimeout;如果超时时间不为0,就挂起线程,然后启动定时器,在定时器回调函数中恢复线程,并返回etimeout

### 发送事件

rt_err_t rt_event_send();

首先判断当前事件的挂起列表是否为空,如果不为空//,就获取挂起列表的第一个线程,

然后设置线程的事件位,如果状态为ok,就在判断之后直接释放该线程,然后启动调度器.//如果为空,就直接判断是否需要调度,然后返回OK

### 删除事件

delete和detach都会释放在事件组中挂起的所有线程,但是并不进行调度

# 邮箱

### 发送邮件

##### rt_err_t rt_mb_send_wait();

首先获取当前线程,然后判断邮箱池的entry是否等于邮箱池的size,如果相等,并且超时时间为0,就直接返回-EFULL.

如果仅仅是entry与size相等,超时时间并不为0,就挂起当前线程,然后设定定时器,在定时器中释放线程并返回etimeout.

如果都不是,那么就让邮箱的entry自增,表示新增一个邮件,然后判断当前邮箱的挂起队列是否为空,如果不为空就释放一个线程,并且调度.为空就返回EOK.

##### rt_err_t rt_mb_send();

与上面相似,就是没有超时时间的设置,当邮箱满的时候直接返回

#### 接收邮件

##### rt_mb_recv();

首先获取当前的线程,然后判断邮箱是否为空并且超时时间是否为0,如果是,就直接返回-etimeout.如果只是邮箱为空,那么就挂起当前线程,设定定时器,等待线程的恢复或者超时恢复.如果邮箱不为空,先把entry自减,然后就判断当前邮箱的挂起队列是否为空,如果不为空,就释放一个线程,然后进行调度.

### 删除邮件

deleta和detach都是直接释放所有挂起线程

即

```c
/* resume all suspended thread */
    _ipc_list_resume_all(&(mb->parent.suspend_thread));
    /* also resume all mailbox private suspended thread */
    _ipc_list_resume_all(&(mb->suspend_sender_thread));
```

# 消息队列

### 消息队列的发送

##### rt_mq_send_wait();

首先判断接收的大小是否大于消息队列的最大接受大小,如果是,直接返回-ERROR.

然后获取一块内存用来存放消息.当==消息队列满==的时候,就判断超时时间,如果有超时时间,就挂起线程,设定定时器,等待被释放.如果超时时间为0,就直接返回.

如果消息队列没有满,就继续进行其他操作(如释放被挂起的等待发送线程).

### 消息队列的接收

rt_mq_recv();

接受时也是先判断一下消息队列是否为空,如果为空就判断超时时间,如果有超时时间,就挂起线程,然后设定定时器,等待被释放.如果没有超时时间,就直接返回.如果消息队列不为空,就继续进行其他操作(如释放被挂起的等待接收线程)..

### 消息队列的删除

detach和deleta都会释放所有因为等待发送或接受的线程,但是并不调度









