# IPC:*(src\ipc.c)*

## 信号量(sem)

### 使用场景

- 临界资源保护(不推荐)
- 线程与线程同步
- 线程与中断同步
- 资源计数

*信号量只能同步一个事件*

### API

##### 动态创建:rt_sem_create(name,value,flag);

flag:RT_IPC_FLAG_FIFO

​		RT_IPC_FLAG_PRIO

##### 静态创建:rt_sem_init(sem,name,value,flag);

##### 获取信号量:rt_sem_take(sem,time);  rt_sem_trytake(sem);

当sem计数为0并且超时时间不为0时,当前线程变成阻塞态.

##### 释放信号量:rt_sem_release(sem);

​		应用:**==中断延迟处理==**

#### else:rt_sem_detach(sem); 

#### 		rt_sem_delet(sem);

#### 		rt_sem_control();

注意:==获取信号量禁止中断上下文应用==

​		==不建议使用信号量进行资源互斥==

## 互斥锁(mutex)

状态只有==解锁==和==上锁==

开锁时:资源可以自由使用

闭锁时:持有的可以再次持有;非持有被挂起或者返回error;

### 使用场景

临界资源保护

为什么不用信号量而用互斥锁 (优先级反转,降低实时性,造成 ?*死锁*? ;互斥锁有==优先级继承==)

*注意事项:尽快释放,持有中不能再更改互斥量线程的优先级.*

### API

略

## 事件组(event)

无排队性



## 邮箱(mailbox)

异步通信方式

用于数据上下文的切换

==不涉及数据的拷贝==

固定4字节(正好32位指针)

==邮箱的发送消息会引起系统的调度,比全局变量实时性高==

==先入先出==

环形缓存

recv不产生调度,send产生调度



## 消息队列(messagequeue)

异步通信

拷贝传递

支持插队

邮箱:大数据传输



---

# 内存管理

静态内存 (编译器)程序开始编译时完成,不占用CPU资源,无需自行分配与释放

动态内存 (程序员)灵活自由,分配与释放都占用cpu资源

静态内存分配在栈上,动态内存分配在堆上.

动态灵活,静态不会产生碎片

线程中调用的局部变量使用的是线程栈空间,大字节buffer不建议使用局部变量

小内存管理,slab管理,memheap



静态内存池:

不会产生内存碎片;只能分配指定大小的内存块,无法任意指定;具有IPC特性,可以挂起线程,FIFO机制;分配和释放比动态快;不会真正的释放内存.

---

rt_malloc不能用在中断中

不能释放野指针	(不要依赖编译器 记得赋初值)

重复释放会断言错误

---

避免:动态分配次数减少,避免连续小字节内存分配

分配与释放一定要匹配

