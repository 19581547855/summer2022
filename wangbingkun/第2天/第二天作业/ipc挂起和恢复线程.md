# ipc能够唤醒，挂起线程的原因

## 以信号量为例子

### 1. 挂起线程：

1. 依靠rt_sem_take（），在函数中首先会判断vlaue值是否大于0。
2. 若大于0则程序能正常运行，若小于或者等于0，则先判断用户自身设置的time值是否走完，若未走完则等待信号量的释放，在此过程中则会挂起线程，首先得到当前的线程，rt_thread_self（），然后挂起当先线程_ipc_list_suspend（），在此过程中会判断用户设置的等待时间是否为0，若不为0则设置线程定时器时间，rt_timer_control（），并开启线程定时器rt_timer_start（），然后执行线程调度函数，则当前线程进入阻塞态，转而去运行其他就绪态的线程（按照优先级执行）。



### 2.恢复线程：

1. 若用户在rt_sem_take（）时设置的超时时间走完仍未得到信号里，则从挂起列表里删除被挂起的线程rt_list_remove(&(thread->tlist))，然后将线程插入到就绪列表中rt_schedule_insert_thread（），线程从阻塞态恢复到就绪态，最后进行线程的调度rt_schedule（），线程是否立即运行根据线程的优先级决定。
2. 若用户设置的超时时间足够大，则会一直等待信号量的释放rt_sem_release（）。
3. 首先查询挂起列表是否为空rt_list_isempty（），若不为空则恢复被挂起的线程_ipc_list_resume（），此时获取信号量线程由阻塞态恢复到就绪态，并设置为需要调度need_schedule = RT_TRUE。
4. 信号量释放后value值++，则获取信号量线程可以获取到信号量。
5. 进行线程调度。



## 互斥量

互斥量是一种特殊的二值信号量，线程的挂起与恢复与信号量相似，不同点在于拥有互斥量的线程可以多次获取互斥量，而不具有互斥量的线程获取互斥量则会进入阻塞态（设置了等待时间），否则直接返回，等待具有互斥量的线程释放互斥量后恢复到就绪态，等待系统调度。



## 事件

1. 事件挂起线程依靠rt_event_recv（），判断用户设置的时间集（与或者或条件是否达到）。
2. 若未达到判断用户是否设置了等待时间，若未设置则直接返回，若设置了则依靠线程定时器进行记时，若设置时间走完则从挂起列表删除，插入到就绪列表，等待系统调度。
3. 若设置时间为waittingforever，则需要rt_event_send（）已发送完相关时间集，然后从挂起列表删除，插入到就绪列表，等待系统调度。



## 邮箱

1. 与时间类似，挂起线程依靠rt_mb_recv（），若未接受到邮件则挂起当前线程（设置了等待时间）。
2. 恢复线程依靠rt_mb_send（）使邮箱中有了邮件，则邮箱不为空接收到了邮件则会从挂起列表中删除，插入到就绪列表等待系统调度。

### 消息队列

  与邮箱类似，挂起和恢复依靠rt_mq_recv（）和rt_mq_send（）。

注：消息队列和邮箱都支持发送紧急消息！









