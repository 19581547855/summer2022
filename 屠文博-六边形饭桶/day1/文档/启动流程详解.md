1. 我们一般习惯从`main()`开始阅读源码, 但是RTT的启动流程并不从`main()`开始.
2. 首先上电复位, 进入`reset_handler()`函数, 进行整个系统的初始化:![image-20220719181939713](./image-20220719181939713.png)
3. 下面挨个看里面的函数:![image-20220719182338524](./image-20220719182338524.png)![image-20220719182414988](./image-20220719182414988.png)
4. ![image-20220719182734271](./image-20220719182734271.png)
5. ![image-20220719182913061](./image-20220719182913061.png)
6. ![image-20220719183254484](./image-20220719183254484.png)
7. 调用`rtthread_startup()`之后就进入RTT的世界了:![image-20220719184538487](./image-20220719184538487.png)
8. ![image-20220719184950580](./image-20220719184950580.png)
9. ![image-20220719185217101](./image-20220719185217101.png)
10. ![image-20220719185538458](./image-20220719185538458.png)
11. 接下来就调用`rt_system_scheduler_start()`开启了任务调度器, 好戏开始!
12. 用户要创建自己的线程, 就可以在main线程里创建, 然后调用API添加到就绪链表里, 从而参与任务调度.
13. 因为main线程是一次性线程, 它执行到`return 0;`之后就会被系统回收掉.